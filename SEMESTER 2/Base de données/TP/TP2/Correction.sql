DROP DATABASE MASD_DBA;

CREATE DATABASE MASD_DBA;

USE MASD_DBA;

-- CRÉATION DE LA TABLE ETUDIANTS
CREATE TABLE ETUDIANTS (
    NUM_ETUDIANT INT IDENTITY PRIMARY KEY,
    NOM VARCHAR(50),
    PRENOM VARCHAR(50),
    BOURSE MONEY,
    DATE_NAISSANCE DATE,
    CODEP VARCHAR(10)
);

-- INSERTIONS
INSERT INTO ETUDIANTS (NOM, PRENOM, BOURSE, DATE_NAISSANCE, CODEP) VALUES ('EL AMRANI', 'FATIMA', 2500.00, '1999-05-15', 'IGE');
INSERT INTO ETUDIANTS (NOM, PRENOM, BOURSE, DATE_NAISSANCE, CODEP) VALUES ('BENALI', 'AHMED', 3000.00, '2000-02-20', 'MAT');
INSERT INTO ETUDIANTS (NOM, PRENOM, BOURSE, DATE_NAISSANCE, CODEP) VALUES ('ZOUHAIRI', 'YASMINE', 2000.00, '1998-11-10', 'PC');
INSERT INTO ETUDIANTS (NOM, PRENOM, BOURSE, DATE_NAISSANCE, CODEP) VALUES ('CHAKIRI', 'MEHDI', 2800.00, '1997-08-25', 'IGE');
INSERT INTO ETUDIANTS (NOM, PRENOM, BOURSE, DATE_NAISSANCE, CODEP) VALUES ('LAMRANI', 'AMINA', 2600.00, '2001-04-30', 'MAT');

-------------------------------------------------------- VARIABLE --------------------------------------------------------
-- DÉCLARATION D'UNE VARIABLE DE TYPE ENTIER
DECLARE @AGE INT;
SET @AGE = 25;

-- DÉCLARATION D'UNE VARIABLE DE TYPE CHAÎNE DE CARACTÈRES
DECLARE @NOM VARCHAR(50);
SET @NOM = 'BOUHLALI';

-- DÉCLARATION D'UNE VARIABLE DE TYPE DATE
DECLARE @DATE_NAISSANCE DATE;
SET @DATE_NAISSANCE = '1990-06-15';

-- AFFICHAGE DES VALEURS DES VARIABLES
SELECT 'ÂGE : ' + CAST(@AGE AS VARCHAR(10)) AS [AGE],
       'NOM : ' + @NOM AS [NOM],
       'DATE DE NAISSANCE : ' + CONVERT(VARCHAR(10), @DATE_NAISSANCE, 120) AS [DATE DE NAISSANCE];

-------------------------------------------------------- IF - ELSE --------------------------------------------------------
DECLARE @AGE_LIMITE INT;
SET @AGE_LIMITE = 20;

IF EXISTS (SELECT * FROM ETUDIANTS WHERE DATEDIFF(YEAR, DATE_NAISSANCE, GETDATE()) > @AGE_LIMITE)
BEGIN
    PRINT 'IL Y A DES ÉTUDIANTS AYANT PLUS DE ' + CAST(@AGE_LIMITE AS VARCHAR(10)) + ' ANS.';
    SELECT * FROM ETUDIANTS WHERE DATEDIFF(YEAR, DATE_NAISSANCE, GETDATE()) > @AGE_LIMITE;
END
ELSE
BEGIN
    PRINT 'IL N''Y A PAS D''ÉTUDIANTS AYANT PLUS DE ' + CAST(@AGE_LIMITE AS VARCHAR(10)) + ' ANS.';
END

-------------------------------------------------------- IF - ELSE IF --------------------------------------------------------
DECLARE @AGE_LIMITE_JEUNE INT;
DECLARE @AGE_LIMITE_MOYEN INT;

SET @AGE_LIMITE_JEUNE = 18;
SET @AGE_LIMITE_MOYEN = 25;

IF EXISTS (SELECT * FROM ETUDIANTS WHERE DATEDIFF(YEAR, DATE_NAISSANCE, GETDATE()) < @AGE_LIMITE_JEUNE)
BEGIN
    PRINT 'IL Y A DES ÉTUDIANTS DE MOINS DE ' + CAST(@AGE_LIMITE_JEUNE AS VARCHAR(10)) + ' ANS.';
    SELECT * FROM ETUDIANTS WHERE DATEDIFF(YEAR, DATE_NAISSANCE, GETDATE()) < @AGE_LIMITE_JEUNE;
END
ELSE IF EXISTS (SELECT * FROM ETUDIANTS WHERE DATEDIFF(YEAR, DATE_NAISSANCE, GETDATE()) < @AGE_LIMITE_MOYEN)
BEGIN
    PRINT 'IL Y A DES ÉTUDIANTS DE MOINS DE ' + CAST(@AGE_LIMITE_MOYEN AS VARCHAR(10)) + ' ANS MAIS PLUS DE ' + CAST(@AGE_LIMITE_JEUNE AS VARCHAR(10)) + ' ANS.';
    SELECT * FROM ETUDIANTS WHERE DATEDIFF(YEAR, DATE_NAISSANCE, GETDATE()) < @AGE_LIMITE_MOYEN;
END
ELSE
BEGIN
    PRINT 'IL Y A DES ÉTUDIANTS DE ' + CAST(@AGE_LIMITE_MOYEN AS VARCHAR(10)) + ' ANS OU PLUS.';
    SELECT * FROM ETUDIANTS WHERE DATEDIFF(YEAR, DATE_NAISSANCE, GETDATE()) >= @AGE_LIMITE_MOYEN;
END

-------------------------------------------------------- IF - ELSE + INSERT UPDATE  --------------------------------------------------------
DECLARE @AGE_LIMITE_JEUNE INT;
DECLARE @AGE_LIMITE_MOYEN INT;

SET @AGE_LIMITE_JEUNE = 18;
SET @AGE_LIMITE_MOYEN = 25;

IF EXISTS (SELECT * FROM ETUDIANTS WHERE DATEDIFF(YEAR, DATE_NAISSANCE, GETDATE()) < @AGE_LIMITE_JEUNE)
BEGIN
    PRINT 'IL Y A DES ÉTUDIANTS DE MOINS DE ' + CAST(@AGE_LIMITE_JEUNE AS VARCHAR(10)) + ' ANS.';
    SELECT * FROM ETUDIANTS WHERE DATEDIFF(YEAR, DATE_NAISSANCE, GETDATE()) < @AGE_LIMITE_JEUNE;
END
ELSE IF EXISTS (SELECT * FROM ETUDIANTS WHERE DATEDIFF(YEAR, DATE_NAISSANCE, GETDATE()) < @AGE_LIMITE_MOYEN)
BEGIN
    PRINT 'IL Y A DES ÉTUDIANTS DE MOINS DE ' + CAST(@AGE_LIMITE_MOYEN AS VARCHAR(10)) + ' ANS MAIS PLUS DE ' + CAST(@AGE_LIMITE_JEUNE AS VARCHAR(10)) + ' ANS.';
    SELECT * FROM ETUDIANTS WHERE DATEDIFF(YEAR, DATE_NAISSANCE, GETDATE()) < @AGE_LIMITE_MOYEN;
END
ELSE
BEGIN
    PRINT 'IL Y A DES ÉTUDIANTS DE ' + CAST(@AGE_LIMITE_MOYEN AS VARCHAR(10)) + ' ANS OU PLUS.';
    -- SÉLECTIONNER LES ÉTUDIANTS DE 'AGE_LIMITE_MOYEN' ANS OU PLUS
    SELECT * FROM ETUDIANTS WHERE DATEDIFF(YEAR, DATE_NAISSANCE, GETDATE()) >= @AGE_LIMITE_MOYEN;

    -- INSÉRER UN NOUVEL ÉTUDIANT
    INSERT INTO ETUDIANTS (NOM, PRENOM, BOURSE, DATE_NAISSANCE, CODEP)
    VALUES ('BEN ABDELLAH', 'NABIL', 1500.00, '2002-03-10', 'SMI');

    -- METTRE À JOUR LA BOURSE POUR TOUS LES ÉTUDIANTS
    UPDATE ETUDIANTS SET BOURSE = BOURSE * 1.1;
END

-------------------------------------------------------- CASE EXAPRESSION --------------------------------------------------------
SELECT NOM, PRENOM,
    CASE LEFT(PRENOM, 1)
        WHEN 'A' THEN 'CATÉGORIE A'
        WHEN 'B' THEN 'CATÉGORIE B'
        WHEN 'C' THEN 'CATÉGORIE C'
        ELSE 'AUTRE CATÉGORIE'
    END AS 'CATEGORIE'
FROM ETUDIANTS;

-------------------------------------------------------- EASE WITHOUT EXPRESSION --------------------------------------------------------
SELECT NOM, PRENOM, DATE_NAISSANCE,
    CASE 
        WHEN DATEDIFF(YEAR, DATE_NAISSANCE, GETDATE()) < 20 THEN 'MOINS DE 20 ANS'
        WHEN DATEDIFF(YEAR, DATE_NAISSANCE, GETDATE()) >= 20 AND DATEDIFF(YEAR, DATE_NAISSANCE, GETDATE()) < 25 THEN '20-24 ANS'
        WHEN DATEDIFF(YEAR, DATE_NAISSANCE, GETDATE()) >= 25 THEN '25 ANS OU PLUS'
        ELSE 'ÂGE NON SPÉCIFIÉ'
    END AS 'CLASSEMENT_AGE'
FROM ETUDIANTS;

-------------------------------------------------------- WHILE --------------------------------------------------------
DECLARE @MOYENNE_BOURSES FLOAT;
DECLARE @BOURSE_MAX MONEY;

-- INITIALISATION DES VARIABLES POUR ENTRER DANS LA BOUCLE
SELECT @MOYENNE_BOURSES = AVG(BOURSE), @BOURSE_MAX = MAX(BOURSE)
FROM ETUDIANTS;

-- BOUCLE WHILE
WHILE @MOYENNE_BOURSES < 80 AND @BOURSE_MAX <= 100
BEGIN
    -- AUGMENTATION DE LA BOURSE DE TOUS LES ÉTUDIANTS
    UPDATE ETUDIANTS SET BOURSE = BOURSE + 10;
    
    -- RECALCUL DE LA MOYENNE ET DE LA BOURSE MAXIMUM
    SELECT @MOYENNE_BOURSES = AVG(BOURSE), @BOURSE_MAX = MAX(BOURSE)
    FROM ETUDIANTS;
END;


-------------------------------------------------------- CURSOR --------------------------------------------------------
-- EXAMPLE 1
DECLARE @NUM_ETUDIANT INT, @BOURSE MONEY;

DECLARE ETUDIANTS_CURSOR CURSOR FOR
SELECT NUM_ETUDIANT, BOURSE
FROM ETUDIANTS;

-- OUVRIR LE CURSEUR
OPEN ETUDIANTS_CURSOR;

-- AFFICHER L'EN-TÊTE
PRINT 'NUM_ETUDIANT -- BOURSE';

-- INITIALISER LES VARIABLES AVEC LA PREMIÈRE LIGNE
FETCH NEXT FROM ETUDIANTS_CURSOR INTO @NUM_ETUDIANT, @BOURSE;

-- TANT QUE LE FETCH SE FAIT NORMALEMENT
WHILE @@FETCH_STATUS = 0 
BEGIN
    -- AFFICHER LES DONNÉES DE L'ÉTUDIANT
    PRINT CONCAT(@NUM_ETUDIANT, ' -- ', @BOURSE);
    
    -- RÉCUPÉRER LA PROCHAINE LIGNE
    FETCH NEXT FROM ETUDIANTS_CURSOR INTO @NUM_ETUDIANT, @BOURSE;
END;

-- FERMER LE CURSEUR
CLOSE ETUDIANTS_CURSOR;

-- LIBÉRER LES RESSOURCES DU CURSEUR
DEALLOCATE ETUDIANTS_CURSOR;

-- EXAMPLE 2
DECLARE @BOURSE MONEY;

DECLARE BOURSE_CURSOR CURSOR FOR
SELECT BOURSE FROM ETUDIANTS;

-- OUVRIR LE CURSEUR
OPEN BOURSE_CURSOR;

-- INITIALISER LA VARIABLE AVEC LA PREMIÈRE LIGNE
FETCH NEXT FROM BOURSE_CURSOR INTO @BOURSE;

-- TANT QUE LE FETCH SE FAIT NORMALEMENT
WHILE @@FETCH_STATUS = 0 
BEGIN
    IF @BOURSE < 500
        UPDATE ETUDIANTS SET BOURSE = BOURSE + (BOURSE * 0.1) WHERE CURRENT OF BOURSE_CURSOR;
    ELSE IF @BOURSE BETWEEN 500 AND 900
        UPDATE ETUDIANTS SET BOURSE = BOURSE + (BOURSE * 0.05) WHERE CURRENT OF BOURSE_CURSOR;
    ELSE
        UPDATE ETUDIANTS SET BOURSE = BOURSE + (BOURSE * 0.01) WHERE CURRENT OF BOURSE_CURSOR;

    -- RÉCUPÉRER LA PROCHAINE LIGNE
    FETCH NEXT FROM BOURSE_CURSOR INTO @BOURSE;
END;

-- FERMER LE CURSEUR
CLOSE BOURSE_CURSOR;

-- LIBÉRER LES RESSOURCES DU CURSEUR
DEALLOCATE BOURSE_CURSOR;

--EXAMPLE 3
DECLARE CURETUDIANTS SCROLL CURSOR FOR 
SELECT NOM, BOURSE FROM ETUDIANTS 
ORDER BY BOURSE DESC;
DECLARE @NOM VARCHAR(50), @BOURSE MONEY;

-- OUVRIR LE CURSEUR
OPEN CURETUDIANTS;

-- AFFICHER LA PREMIÈRE LIGNE
PRINT('LA PREMIÈRE LIGNE:');
FETCH FIRST FROM CURETUDIANTS INTO @NOM, @BOURSE;
PRINT CONCAT(@NOM, ' ---- ', @BOURSE);

-- AFFICHER LA DERNIÈRE LIGNE
PRINT('LA DERNIÈRE LIGNE:');
FETCH LAST FROM CURETUDIANTS INTO @NOM, @BOURSE;
PRINT CONCAT(@NOM, ' ---- ', @BOURSE);

-- AFFICHER LA LIGNE NUMÉRO 3
PRINT('LA LIGNE NUMÉRO 3:');
FETCH ABSOLUTE 3 FROM CURETUDIANTS INTO @NOM, @BOURSE;
PRINT CONCAT(@NOM, ' ---- ', @BOURSE);

-- AFFICHER LA DEUXIÈME LIGNE APRÈS LA LIGNE 3
PRINT('LA DEUXIÈME LIGNE APRÈS LA LIGNE 3:');
FETCH RELATIVE 2 FROM CURETUDIANTS INTO @NOM, @BOURSE;
PRINT CONCAT(@NOM, ' ---- ', @BOURSE);

-- AFFICHER LA LIGNE IMMÉDIATEMENT AVANT LA POSITION COURANTE
PRINT('LA LIGNE IMMÉDIATEMENT AVANT LA POSITION COURANTE:');
FETCH PRIOR FROM CURETUDIANTS INTO @NOM, @BOURSE;
PRINT CONCAT(@NOM, ' ---- ', @BOURSE);

-- AFFICHER LA LIGNE QUI EST DEUX LIGNES AVANT LA LIGNE COURANTE
PRINT('LA LIGNE QUI EST DEUX LIGNES AVANT LA LIGNE COURANTE:');
FETCH RELATIVE -2 FROM CURETUDIANTS INTO @NOM, @BOURSE;
PRINT CONCAT(@NOM, ' ---- ', @BOURSE);

-- FERMER LE CURSEUR
CLOSE CURETUDIANTS;

-- LIBÉRER LES RESSOURCES DU CURSEUR
DEALLOCATE CURETUDIANTS;

-------------------------------------------------------- PROCEDURE STOCKE --------------------------------------------------------
--EXAMPLE 1
CREATE PROCEDURE INSERERETUDIANT
    @NOM VARCHAR(50),
    @PRENOM VARCHAR(50),
    @BOURSE MONEY,
    @DATE_NAISSANCE DATE,
    @CODEP VARCHAR(10)
AS
BEGIN
    INSERT INTO ETUDIANTS (NOM, PRENOM, BOURSE, DATE_NAISSANCE, CODEP)
    VALUES (@NOM, @PRENOM, @BOURSE, @DATE_NAISSANCE, @CODEP);
END;


EXEC INSERERETUDIANT 'BOUHLALI', 'ABDELFATTAH', 2000.00, '2000-01-01', 'IGE';

EXEC INSERERETUDIANT 
    @NOM = 'ABATOUR' , 
    @PRENOM = 'DRISS' , 
    @BOURSE = 2000.00 , 
    @DATE_NAISSANCE = '2000-01-01' , 
    @CODEP = 'MAT';


-- EXAMPLE 2
CREATE PROCEDURE CHERCHERETUDIANTPARNOM
    @NOMRECHERCHE VARCHAR(50)
AS
BEGIN
    SELECT *
    FROM ETUDIANTS
    WHERE NOM = @NOMRECHERCHE;
END;


EXEC CHERCHERETUDIANTPARNOM @NOMRECHERCHE = 'BOUHLALI';


-------------------------------------------------------- LES FONCTIONS --------------------------------------------------------

-- EXAMPLE 1 
CREATE FUNCTION COMPTERETUDIANTS()
RETURNS INT
AS
BEGIN
    DECLARE @COUNT INT;
    SET @COUNT = (SELECT COUNT(*) FROM ETUDIANTS);
    RETURN @COUNT;
END;


SELECT DBO.COMPTERETUDIANTS();
GO

-- EXAMPLE 2 
CREATE FUNCTION COMPTER_ETUDIANTS(@PCODE CHAR(3)) 
RETURNS INT
AS
BEGIN
    DECLARE @TOTAL INT;
    SELECT @TOTAL = COUNT(*) FROM ETUDIANTS WHERE CODEP = @PCODE;
    RETURN @TOTAL;
END
GO

SELECT DBO.COMPTER_ETUDIANTS('IGE'); -- EXEMPLE POUR LE CODE 'IGE'
GO 

-- RETURNER UNE TABLE 
CREATE FUNCTION CHERCHERTOUSETUDIANTS
(@PCODEP CHAR(3)) RETURNS TABLE
AS
RETURN(
SELECT NOM,PRENOM
 FROM ETUDIANTS
 WHERE @PCODEP =CODEP
 ) ;
GO

-- COMME SI ON SELECTIONNE UNE TABLE 
SELECT * FROM DBO.CHERCHERTOUSETUDIANTS('IGE')
GO

-- SUPPRISSION DES PROCEDURES ET FONCTIONS 
DROP PROCEDURE CHERCHERETUDIANTPARNOM
GO

DROP FUNCTION DBO.CHERCHERTOUSETUDIANTS
GO

-------------------------------------------------------- LES TRIGGERS --------------------------------------------------------

-- AJOUT DE LA COLONNE DATE_MODIFICATION À LA TABLE ETUDIANTS
ALTER TABLE ETUDIANTS
ADD DATE_MODIFICATION DATETIME;



-- CRÉATION DU DÉCLENCHEUR POUR LA TABLE ETUDIANTS
CREATE TRIGGER TRG_ETUDIANTS_DATE_MODIFICATION
ON ETUDIANTS
AFTER INSERT, UPDATE
AS
BEGIN
    -- MISE À JOUR DE LA COLONNE DATE_MODIFICATION AVEC LA DATE ET L'HEURE ACTUELLES
    UPDATE ETUDIANTS
    SET DATE_MODIFICATION = GETDATE()
    WHERE NUM_ETUDIANT IN (SELECT NUM_ETUDIANT FROM INSERTED);
END;

-- INSERTION D'UN NOUVEL ÉTUDIANT DANS LA TABLE ETUDIANTS

INSERT INTO ETUDIANTS (NOM, PRENOM, BOURSE, DATE_NAISSANCE, CODEP)
VALUES ('MOHAMMED', 'AIT BRAHIM', 1500.00, '2000-01-15', 'IGE');

UPDATE ETUDIANTS
SET NOM = 'BOUHLALI'
WHERE ETUDIANTS.NUM_ETUDIANT = 6;
GO

SELECT * FROM ETUDIANTS 
GO


-- AUTRE TABLES 


-- CRÉATION DE LA TABLE DEPARTEMENT
CREATE TABLE DEPARTEMENT (
    ID_DEPARTEMENT INT PRIMARY KEY,
    NOM_DEPARTEMENT VARCHAR(50),
    CHEF_DEPARTEMENT VARCHAR(100),
    LIEU_DEPARTEMENT VARCHAR(100)
);
GO 


-- CRÉATION DE LA TABLE EMPLOYE
CREATE TABLE EMPLOYE (
    ID_EMPLOYE INT PRIMARY KEY,
    NOM VARCHAR(50),
    PRENOM VARCHAR(50),
    DATE_EMBAUCHE DATE,
    SALAIRE DECIMAL(10, 2),
    ID_DEPARTEMENT INT,
    FOREIGN KEY (ID_DEPARTEMENT) REFERENCES DEPARTEMENT(ID_DEPARTEMENT)
);


-- INSERTIONS DANS LA TABLE DEPARTEMENT 
INSERT INTO DEPARTEMENT (ID_DEPARTEMENT, NOM_DEPARTEMENT, CHEF_DEPARTEMENT, LIEU_DEPARTEMENT)
VALUES 
(1, 'RESSOURCES HUMAINES', 'AHMED EL MOKHTAR', 'CASABLANCA'),
(2, 'DÉVELOPPEMENT', 'FATIMA ZOHRA OUDGHIRI', 'RABAT'),
(3, 'COMPTABILITÉ', 'MOHAMMED BEN ALI', 'MARRAKECH'),
(4, 'MARKETING', 'NAJAT EL HOUARI', 'TANGER');



-- INSERTIONS DANS LA TABLE EMPLOYE 
INSERT INTO EMPLOYE (ID_EMPLOYE, NOM, PRENOM, DATE_EMBAUCHE, SALAIRE, ID_DEPARTEMENT)
VALUES 
(1, 'AIT BOUZID', 'YOUSSEF', '2020-05-15', 5000.00, 1),
(2, 'BOUHJAR', 'FATIMA', '2019-08-20', 4800.00, 2),
(3, 'EL KASSIMI', 'AHMED', '2021-03-10', 5500.00, 3),
(4, 'EL HACHIMI', 'NAJWA', '2018-11-25', 5200.00, 4);


SELECT * FROM EMPLOYE ;
GO 

SELECT * FROM DEPARTEMENT;
GO

-- Delete On Cascade
CREATE TRIGGER TRG_DEPARTEMENT_AFTER_DELETE
ON DEPARTEMENT
AFTER DELETE
AS
BEGIN
    -- SUPPRIMER LES EMPLOYÉS ASSOCIÉS AU DÉPARTEMENT SUPPRIMÉ
    DELETE FROM EMPLOYE WHERE ID_DEPARTEMENT IN (SELECT ID_DEPARTEMENT FROM DELETED);
END;
GO

--After Update

CREATE TRIGGER ctrlSalaireEmployé ON EMPLOYE AFTER UPDATE
AS
DECLARE
    @ancienSalaire DECIMAL(10, 2),
    @nouveauSalaire DECIMAL(10, 2);
BEGIN
    SELECT @ancienSalaire = SALAIRE FROM deleted;
    SELECT @nouveauSalaire = SALAIRE FROM inserted;
    
    IF (@ancienSalaire > @nouveauSalaire)
    BEGIN
        ROLLBACK;
        RAISERROR ('Le nouveau salaire ne peut pas être inférieur à l`ancien salaire.', 16, 1);
    END;
END;


-- Update the employee's salary to a lower value
UPDATE EMPLOYE SET SALAIRE = 4500.00 WHERE ID_EMPLOYE = 1;



----------------------------RAISERROR--------------------------------------------------

-- Syntax
RAISERROR (message_string, gravité, état)

--message_string : Il s'agit du texte du message d'erreur. Il peut être une chaîne littérale ou une variable.

--gravité : Il s'agit du niveau de gravité de l'erreur. Il va de 0 à 25. Les niveaux de gravité 0 à 10 sont considérés comme informatifs,
	--11 à 16 sont considérés comme des erreurs pouvant être corrigées par l'utilisateur, et 17 à 25 sont considérés comme des erreurs système.

--état : Il s'agit d'un état d'erreur défini par l'utilisateur. Il doit être une valeur de 0 à 255. Il est utilisé pour aider à identifier le 
	--point dans le code où l'erreur s'est produite.


--Example s
DECLARE @ErrorMessage NVARCHAR(100) = 'Custom error message';
RAISERROR (@ErrorMessage, 16, 1);

